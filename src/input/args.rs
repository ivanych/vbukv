//! Разбор аргументов командной строки

#[cfg(test)]
mod tests;

use clap::Parser;
use clap_markdown;
use std::ffi::OsString;
use std::path::PathBuf;
use std::process::exit;

use crate::libvbukv::rule::Rule;

#[derive(Parser, Debug)]
#[command(version, about, long_about)]
/// Угадывалка слов по буквам
///
/// Программа ищет слово (или слова) в словаре по заданным правилам.
/// Например: "слово из пяти букв, третья буква Б, четвёртая не Ю
/// и где-то в слове есть буква Ш".
pub struct Args {
    /// Длина искомого слова.
    ///
    /// Будут найдены только те слова, которые состоят из указанного количества букв.
    #[arg(short, long, default_value_t = 5)]
    // TODO Почему-то эта строчка не попадает в покрытие тестами. Надо разобраться.
    pub length: usize,

    /// Файл словаря.
    ///
    /// Относительный путь к файлу словаря.
    /// Словарь должен быть в формате plain text, одно слово в строке, кодировка utf-8.
    #[arg(short, long, default_value = "slovar.txt")]
    // TODO Почему-то эта строчка не попадает в покрытие тестами. Надо разобраться.
    pub file: PathBuf,

    /// Правило поиска (можно задать любое количество правил).
    ///
    /// Правила — это фильтры, которые говорят программе, какие слова следует выбрать из словаря.
    /// Выбираются только те слова, которые соответствуют ВСЕМ заданным правилам.
    ///
    /// Каждое правило должно соответствовать шаблону:
    ///
    /// `L[C][P]`
    ///
    /// где:
    ///
    /// L — буква
    ///
    /// C — условие; по умолчанию `+`
    ///
    /// Возможны 4 условия:
    ///
    /// `+` — буква есть в слове (либо, если позиция указана, то есть на указанной позиции)
    ///
    /// `-` — буквы нет в слове (либо, если позиция указана, то нет на указанной позиции)
    ///
    /// `=` — буква есть только на указанной позиции и нигде больше
    ///
    /// `*` — буква есть на любой позиции, кроме указанной
    ///
    /// P — позиция буквы в слове
    ///
    /// Если позиция не указана, то поиск происходит по всему слову.
    ///
    /// Позиция обязательно должна быть указана для условий `=` и `*`.
    ///
    /// Примеры правил:
    ///
    /// `а` — в слове есть буква `а`
    ///
    /// `а+` — то же самое, что предыдущий вариант, но условие задано явно
    ///
    /// `а1` — первая буква в слове это буква `а`. При этом в слове могуть быть ещё буквы `а`
    /// на других местах.
    ///
    /// `а+1` — то же самое, что предыдущий вариант, но условие задано явно
    ///
    /// `а=1` — первая буква в слове это буква `а`. При этом в слове нет других букв `а`.
    ///
    /// `б-` — в слове нет буквы `б`
    ///
    /// `б-1` — первая буква в слове это не буква `б`. При этом в слове могут быть буквы `б`
    ///  на других местах
    ///
    /// `б*1` — первая буква в слове это не буква `б`. При этом в слове есть буква `б`
    /// на каком-то другом месте.
    #[arg(value_name = "RULE")]
    // TODO Надо Vec<Rule> переделать на структуру Rules
    pub rules: Vec<Rule>,

    #[arg(long, hide = true)]
    // TODO Почему-то эта строчка не попадает в покрытие тестами. Надо разобраться.
    pub markdown_help: bool,
}

// TODO Эту функцию пока не получается покрыть тестами,
// потому что непонятно как мокнуть Args::parse().
// Надо разобраться.
pub fn parse() -> Args {
    let args = Args::parse();

    markdown_help(&args);

    args
}

// TODO сигнатура списана один-в-один с функции parse_from,
// в которую дальше передаём itr.
// Надо разобраться, как это работает.

/// Разобрать список значений, синтаксически аналогичный аргументам командной строки
///
/// # SYNOPSIS
/// ```
/// use vbukv::input::args;
/// let args = args::parse_from(["vbukv,", "-l", "5", "-f", "test_slovar.txt", "c+"]);
///
/// assert_eq!(args.length, 5);
/// assert_eq!(args.file.into_os_string(), "test_slovar.txt");
/// assert_eq!(args.rules.len(), 1);
/// assert_eq!(args.rules.iter().nth(0).unwrap().letter, 'c');
/// ```
///
/// # DESCRIPTION
///
/// Это вспомогательная функция (основная — [parse]).
/// Эта функция используется в тех случаях, когда параметры программы задаются
/// не аргументами командной строки (основной способ), а как-либо иначе,
/// например — берутся из конфига.
///
/// Функция принимает список значений, идентичный тем,
/// которые передаются в программу при запуске её в командной строке:
///
/// 1. Название программы. Это значение требуется здесь по формальным причинам,
/// для точного соответствия аргументам командной строки.
/// Можно задать любое значение, в дальнейшей работе это значение
/// никак не используется.
/// 2. Необязательные опций, каждая задаётся парой "название/значение"
///    * -l (--length) Длина искомых слов [по умолчанию: 5]
///    * -f (--file) Файл словаря [по умолчанию: slovar.txt]
/// 3. Необязательные правила поиска.
/// Описание правил поиска см. в документации структуры [Args], поле `rules`.
///
/// Функция возвращает структуру [Args] точно так же,
/// как её возвращает основная функция [parse].
pub fn parse_from<I, T>(itr: I) -> Args
where
    I: IntoIterator<Item = T>,
    T: Into<OsString> + Clone,
{
    let args = Args::parse_from(itr);

    markdown_help(&args);

    args
}

// TODO Эту функцию пока не получается покрыть тестами,
// потому что непонятно как мокнуть exit().
// Надо разобраться.
fn markdown_help(args: &Args) {
    if args.markdown_help {
        clap_markdown::print_help_markdown::<Args>();
        exit(0);
    }
}
